//
//  DrawingViewController.m
//  Pictaphone
//
//  Created by Kelly Hutchison on 11/22/14.
//  Copyright (c) 2014 Kelly Hutchison. All rights reserved.
//

#import "DrawingViewController.h"
#import "StoryViewController.h"
#import "TypingViewController.h"
#import "PenSettingsViewController.h"
#import "ConfirmationViewController.h"
#import "ViewLastTurnViewController.h"
#import "model.h"

#define THIN 5.0f
#define MEDIUM 13.0f
#define THICK 20.0f

@interface DrawingViewController ()
@property (nonatomic,strong) model *model;

@property (weak, nonatomic) IBOutlet UISegmentedControl *segmentedControlOutlet;
- (IBAction)segmentControlPressed:(id)sender;

@property (weak, nonatomic) IBOutlet UIButton *undoButton;
- (IBAction)undoButtonPressed:(id)sender;
@property (nonatomic, strong) NSMutableArray *drawStack;

@property (strong, nonatomic) IBOutlet UIView *drawingView;
@property (nonatomic, assign) CGRect drawingViewFrame;

@property (weak, nonatomic) IBOutlet UIImageView *resetPressed;

// Game Settings Properties
@property (nonatomic, assign) NSInteger roundCount;
@property (nonatomic, assign) NSInteger playerCount;
@property (nonatomic, assign) BOOL firstRoundAutoGenerated;
@property (nonatomic, assign) NSString *firstRoundType;

@property (weak, nonatomic) IBOutlet UILabel *roundLabel;
@property (weak, nonatomic) IBOutlet UILabel *playerLabel;
@property (weak, nonatomic) IBOutlet UIButton *endOfGameDoneButton;
- (IBAction)endOfRoundPressed:(id)sender;

@property (weak, nonatomic) IBOutlet UIButton *doneButton;
- (IBAction)doneButtonPressed:(id)sender;

@property (nonatomic, assign) NSString *lastRoundPhrase;
@property (weak, nonatomic) IBOutlet UIButton *viewLastTurnButton;
- (IBAction)viewLastTurnPressed:(id)sender;

@property (weak, nonatomic) IBOutlet UILabel *clickHereLabel;
@property (weak, nonatomic) IBOutlet UIImageView *clickHereArrow;

@end

@implementation DrawingViewController
CGFloat drawOpacity;
CALayer* drawLayer;
UIImage* mainImage;
UIImage* drawImage;
CGPoint lastPoint;
CGPoint currentPoint;

- (id)initWithCoder:(NSCoder *)aDecoder
{
    self = [super initWithCoder:aDecoder];
    if (self) {
        // Custom initialization
        _model = [model sharedInstance];
    }
    return self;
}

- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    self.view.opaque = YES;
    self.view.backgroundColor = [UIColor colorWithWhite:5.0 alpha:0.95];
    
    [self.navigationController setNavigationBarHidden:YES animated:NO];
    
    if(!self.autoGenerate)
    {
        self.firstRoundAutoGenerated = NO;
    }
    else {
        self.firstRoundAutoGenerated = YES;
    }
    
    // Set up drawing view and frame
    self.drawingViewFrame = self.drawingView.frame;
    self.drawingView.layer.borderWidth = 5.0f;
    self.drawingView.layer.borderColor = [[UIColor blackColor] CGColor];
    
    [self initializePen];
    [self initializeGameSettings];
}

- (void)didReceiveMemoryWarning
{
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

-(void)initializeGameSettings
{
    [self initializeLastRoundButton];
    
    // Check if this is the last turn
    NSInteger turnsRemaining = [self.model turnsRemaining];
    if(turnsRemaining == 1) {
        self.doneButton.hidden = YES;
        self.endOfGameDoneButton.hidden = NO;
    } else {
        self.doneButton.hidden = NO;
        self.endOfGameDoneButton.hidden = YES;
    }
    
    // allocate stack for undo-ing and hide the undo button since the screen will be blank
    self.drawStack = [[NSMutableArray alloc] init];
    self.undoButton.hidden = YES;
    self.undoButton.enabled = NO;
    
    NSInteger currentRound = [self.model currentRound];
    [self.roundLabel setText:[NSString stringWithFormat:@"%@%ld", @"Round: ", (long)currentRound]];
    
    NSInteger currentPlayer = [self.model currentPlayer];
    [self.playerLabel setText:[NSString stringWithFormat:@"%@%ld", @"Player: ", (long)currentPlayer]];
    
    // Show/Hide the click here label during first round
    if(currentRound == 1) {
        if([self.model currentTurn]== 1 && !self.firstRoundAutoGenerated) {
            self.clickHereArrow.hidden = YES;
            self.clickHereLabel.hidden = YES;
        } else {
            self.clickHereArrow.hidden = NO;
            self.clickHereLabel.hidden = NO;
        }
    } else {
        self.clickHereArrow.hidden = YES;
        self.clickHereLabel.hidden = YES;
    }
}

-(void)initializeLastRoundButton
{
    // Check if first image is auto generated
    // Check if this is first round/auto generate
    if([self.model currentTurn]== 1) {
        if(self.firstRoundAutoGenerated) {
            self.viewLastTurnButton.hidden = NO;
            self.viewLastTurnButton.userInteractionEnabled = YES;
            
            // Set random icon image
            self.lastRoundPhrase = self.randomPhrase;
            UIImage *image = [UIImage imageNamed:@"sentences.png"];
            [self.viewLastTurnButton setImage:image forState:UIControlStateNormal];
        }
        else {
            self.viewLastTurnButton.hidden = YES;
            self.clickHereArrow.hidden = YES;
            self.clickHereLabel.hidden = YES;
        }
    }
    else {
        self.viewLastTurnButton.hidden = NO;
        self.viewLastTurnButton.userInteractionEnabled = YES;
        
        // Set random icon image
        NSInteger lastIndex = [self.model contentsArrayCount]-1;
        self.lastRoundPhrase = [self.model valueOfContentsArrayAtIndex:lastIndex];
        UIImage *image = [UIImage imageNamed:@"sentences.png"];
        [self.viewLastTurnButton setImage:image forState:UIControlStateNormal];
    }
    
    // Set button border
    self.self.viewLastTurnButton.layer.borderWidth = 5.0f;
    self.self.viewLastTurnButton.layer.borderColor = [[UIColor grayColor] CGColor];
    [self.viewLastTurnButton setContentMode:UIViewContentModeRedraw];
}

- (void)initializePen
{
    _toolType = Paint;
    _drawOpacity = 1.0f;
    _drawColor = [UIColor blackColor];
    _drawWidth = 5.0f;
    
    drawLayer = [[CALayer alloc] init];
    drawLayer.frame = CGRectMake(0.0f, 0.0f, self.drawingView.layer.frame.size.width, self.drawingView.layer.frame.size.height);
    mainImage = nil;
    drawImage = nil;
    
    [self.drawingView.layer addSublayer:drawLayer];
    [self clearToColor:self.drawingView.backgroundColor];
}


- (void) drawLineFrom:(CGPoint)from to:(CGPoint)to width:(CGFloat)width
{
    UIGraphicsBeginImageContext(self.drawingView.frame.size);
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    CGContextScaleCTM(ctx, 1.0f, -1.0f);
    CGContextTranslateCTM(ctx, 0.0f, -self.drawingView.frame.size.height);
    if (drawImage != nil) {
        CGRect rect = CGRectMake(0.0f, 0.0f, self.drawingView.frame.size.width, self.drawingView.frame.size.height);
        CGContextDrawImage(ctx, rect, drawImage.CGImage);
    }
    CGContextSetLineCap(ctx, kCGLineCapRound);
    CGContextSetLineWidth(ctx, width);
    CGContextSetStrokeColorWithColor(ctx, self.drawColor.CGColor);
    CGContextMoveToPoint(ctx, from.x, from.y);
    CGContextAddLineToPoint(ctx, to.x, to.y);
    CGContextStrokePath(ctx);
    CGContextFlush(ctx);
    drawImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    drawLayer.contents = (id)drawImage.CGImage;
}

- (void) eraseLineFrom:(CGPoint)from to:(CGPoint)to width:(CGFloat)width
{
    UIGraphicsBeginImageContext(self.drawingView.frame.size);
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    CGContextScaleCTM(ctx, 1.0f, -1.0f);
    CGContextTranslateCTM(ctx, 0.0f, -self.drawingView.frame.size.height);
    if (drawImage != nil) {
        CGRect rect = CGRectMake(0.0f, 0.0f, self.drawingView.frame.size.width, self.drawingView.frame.size.height);
        CGContextDrawImage(ctx, rect, drawImage.CGImage);
    }
    CGContextSetLineCap(ctx, kCGLineCapRound);
    CGContextSetLineWidth(ctx, width);
    CGContextSetStrokeColorWithColor(ctx, [UIColor whiteColor].CGColor);
    CGContextMoveToPoint(ctx, from.x, from.y);
    CGContextAddLineToPoint(ctx, to.x, to.y);
    CGContextStrokePath(ctx);
    CGContextFlush(ctx);
    drawImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    drawLayer.contents = (id)drawImage.CGImage;
}

- (void) commitDrawingWithOpacity:(CGFloat)opacity
{
    UIGraphicsBeginImageContextWithOptions(self.drawingView.bounds.size, NO, 1.0);
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    CGContextScaleCTM(ctx, 1.0f, -1.0f);
    CGContextTranslateCTM(ctx, 0.0f, -self.drawingView.frame.size.height);
    CGRect rect = CGRectMake(0.0f, 0.0f, self.drawingView.frame.size.width, self.drawingView.frame.size.height);
    if (mainImage != nil) {
        CGContextDrawImage(ctx, rect, mainImage.CGImage);
    }
    CGContextSetAlpha(ctx, opacity);
    CGContextDrawImage(ctx, rect, drawImage.CGImage);
    mainImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    // Add new drawing to stack for undo-ing
    [self.drawStack addObject:mainImage];
    
    // if undo button is hidden, show it
    if(self.undoButton.hidden)
    {
        self.undoButton.hidden = NO;
        self.undoButton.enabled = YES;
    }
    
    self.drawingView.layer.contents = (id)mainImage.CGImage;
    drawLayer.contents = nil;
    drawImage = nil;
}

- (IBAction)undoButtonPressed:(id)sender {
    
    // Check if there is at least 2 items to undo
    if([self.drawStack count] > 1)
    {
        // pop the top CGImage from the stack
        [self.drawStack removeLastObject];
        
        // get last image (top of stack)
        UIImage *imageToReplace = [self.drawStack objectAtIndex:([self.drawStack count] - 1)];
        
        // assign to draw layer
        self.drawingView.layer.contents = (id)imageToReplace.CGImage;
        mainImage = imageToReplace;
    }
    // else if there is only one, remove it (stack will now be empty) and clear the screen
    else if([self.drawStack count] == 1)
    {
        [self.drawStack removeLastObject];
        [self clearToColor:[UIColor clearColor]];
        
        self.undoButton.hidden = YES;
        self.undoButton.enabled = NO;
    }
}

- (void)paintTouchesBegan
{
    [self drawLineFrom:lastPoint to:lastPoint width:self.drawWidth];
}

- (void)paintTouchesMoved
{
    [self drawLineFrom:lastPoint to:currentPoint width:self.drawWidth];
}

- (void) paintTouchesEnded
{
    [self commitDrawingWithOpacity:self.drawOpacity];
}

- (void)eraseTouchesBegan
{
    [self eraseLineFrom:lastPoint to:lastPoint width:THICK];
}

- (void)eraseTouchesMoved
{
    [self eraseLineFrom:lastPoint to:currentPoint width:THICK];
}

- (void) eraseTouchesEnded
{
    [self commitDrawingWithOpacity:THICK];
}


- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    // Get touch and point of touch location
    UITouch *touch = [touches anyObject];
    CGPoint touchLocation = [touch locationInView:self.view];
    
    // check that drawing view is enabled and if touch is in the drawing view
    if(!self.drawingView.userInteractionEnabled || !CGRectContainsPoint(self.drawingView.frame, touchLocation))
    {
        [super touchesBegan:touches withEvent:event];
        return;
    }
    
    lastPoint = [touch locationInView:self.drawingView];
    lastPoint.y = self.drawingView.frame.size.height - lastPoint.y;
    
    if (self.toolType == Paint) {
        [self paintTouchesBegan];
    }
    else if (self.toolType == Erase)
    {
        [self eraseTouchesBegan];
    }
}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
    
    // Get touch and point of touch location
    UITouch *touch = [touches anyObject];
    CGPoint touchLocation = [touch locationInView:self.view];
    
    // check that drawing view is enabled and if touch is in the drawing view
    if (!self.drawingView.userInteractionEnabled || !CGRectContainsPoint(self.drawingView.frame, touchLocation)) {
        [super touchesMoved:touches withEvent:event];
        return;
    }
    
    currentPoint = [touch locationInView:self.drawingView];
    currentPoint.y = self.drawingView.frame.size.height - currentPoint.y;
    
    if (self.toolType == Paint) {
        [self paintTouchesMoved];
    }
    else if (self.toolType == Erase)
    {
        [self eraseTouchesMoved];
    }
    
    lastPoint = currentPoint;
}

- (void) touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
    // Get touch and point of touch location
    UITouch *touch = [touches anyObject];
    CGPoint touchLocation = [touch locationInView:self.view];
    
    // check that drawing view is enabled and if touch is in the drawing view
    if (!self.drawingView.userInteractionEnabled || !CGRectContainsPoint(self.drawingView.frame, touchLocation)) {
        [super touchesEnded:touches withEvent:event];
        return;
    }
    
    if (self.toolType == Paint) {
        [self paintTouchesEnded];
    }
    else if (self.toolType == Erase)
    {
        [self eraseTouchesEnded];
    }
}

- (void) touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
{
    // Get touch and point of touch location
    UITouch *touch = [touches anyObject];
    CGPoint touchLocation = [touch locationInView:self.view];

    if (!self.drawingView.userInteractionEnabled || !CGRectContainsPoint(self.drawingView.frame, touchLocation)) {
        [super touchesCancelled:touches withEvent:event];
        return;
    }
    [self touchesEnded:touches withEvent:event];
}

- (void) clearToColor:(UIColor*)color
{
    UIGraphicsBeginImageContextWithOptions(self.drawingView.bounds.size, NO, 1.0);
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    CGRect rect = CGRectMake(0.0f, 0.0f, self.drawingView.frame.size.width, self.drawingView.frame.size.height);
    CGContextSetFillColorWithColor(ctx, color.CGColor);
    CGContextFillRect(ctx, rect);
    CGContextFlush(ctx);
    mainImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    self.drawingView.layer.contents = (id)mainImage.CGImage;
}


- (UIImage*) getSketch;
{
    return mainImage;
}

- (void) setSketch:(UIImage*)sketch
{
    self.drawingView.backgroundColor = [UIColor clearColor];
    self.drawingView.layer.borderColor = [[UIColor clearColor] CGColor];
    
    UIImageView* imageView = [[UIImageView alloc] initWithFrame:self.drawingView.bounds];
    imageView.contentMode = self.drawingView.contentMode;
    imageView.image = sketch;
    imageView.backgroundColor = [UIColor clearColor];
    
    UIGraphicsBeginImageContextWithOptions(self.drawingView.bounds.size, NO, 1.0);
    [imageView.layer renderInContext:UIGraphicsGetCurrentContext()];
    mainImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    [self commitDrawingWithOpacity:1.0f];
}

- (void) updateDrawOpacityWith:(CGFloat)drawOpacity
{
    _drawOpacity = drawOpacity;
    drawLayer.opacity = _drawOpacity;
}


#pragma mark - Navigation

// In a storyboard-based application, you will often want to do a little preparation before navigation
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    // Get the new view controller using [segue destinationViewController].
    // Pass the selected object to the new view controller.
    if([segue.identifier isEqualToString:@"penSettingsSegue"])
    {
        PenSettingsViewController *colorViewController = segue.destinationViewController;
        UIColor *color = self.drawColor;
        colorViewController.pageColor = color;
        
        CGFloat penWidth = self.drawWidth;
        colorViewController.drawWidth = penWidth;
        
        colorViewController.drawWidthCompletionBlock = ^(CGFloat value){
            self.drawWidth = value;
        };
        
        colorViewController.completionBlock = ^(id value){
            [self dismissViewControllerAnimated:YES completion:NULL];
            NSDictionary *dictionary = value;
            UIColor *color = [dictionary objectForKey:@"color"];
            self.drawColor = color;
        };
        
    }
    // erase current drawing view
    else if([segue.identifier isEqualToString:@"confirmErase"])
    {
        ConfirmationViewController *confirmEraseViewController = segue.destinationViewController;
        confirmEraseViewController.completionBlock = ^{
            [self dismissViewControllerAnimated:YES completion:NULL];
            
            self.drawStack = [[NSMutableArray alloc] init];
            
            self.undoButton.hidden = YES;
            self.undoButton.enabled = NO;
            
            [self clearToColor:[UIColor clearColor]];
        };
    }
    
    // previous turn phrase
    else if ([segue.identifier isEqualToString:@"lastTurn"])
    {
        ViewLastTurnViewController *lastTurnVC = segue.destinationViewController;
        lastTurnVC.sentence = self.lastRoundPhrase;
        lastTurnVC.contentToDisplay = @"phrase";
    }
}


- (IBAction)segmentControlPressed:(id)sender {
    UISegmentedControl *segmentedControl = (UISegmentedControl*) sender;
    NSInteger segmentClicked = segmentedControl.selectedSegmentIndex;
    
    // Paint
    if (segmentClicked == 0) {
        self.toolType = Paint;
    }
    // Erase
    else {
        self.toolType = Erase;
    }
    
}

// Game Over
- (IBAction)endOfRoundPressed:(id)sender {
    UIImage *drawing = [self imageWithView:self.drawingView];
    
    [self.model trackFinishedTurn];
    [self.model populateContentsArrayWithImage:drawing];
}

// Go to Typing view controller
- (IBAction)doneButtonPressed:(id)sender {
    
    UIImage *drawing = [self imageWithView:self.drawingView];
    
    [self.model trackFinishedTurn];
    [self.model populateContentsArrayWithImage:drawing];
}

- (UIImage *) imageWithView:(UIView *)view
{
    UIGraphicsBeginImageContextWithOptions(view.bounds.size, view.opaque, 0.0);
    [view.layer renderInContext:UIGraphicsGetCurrentContext()];
    
    UIImage * img = UIGraphicsGetImageFromCurrentImageContext();
    
    UIGraphicsEndImageContext();
    
    return img;
}

- (IBAction)viewLastTurnPressed:(id)sender {
}

@end
